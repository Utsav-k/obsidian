Load Balancer System Design
System Architecture
text

┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Clients       │───▶│  Load Balancer   │───▶│   Backend       │
│                 │    │                  │    │   Servers       │
│ Web/Mobile/API  │    │ (Multiple Layers)│    │ (App Servers)   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │                         │
                      ┌───────┴───────┐         ┌───────┴───────┐
                      │  Health       │         │  Service      │
                      │  Checks       │         │  Discovery    │
                      └───────────────┘         └───────────────┘

Core Components
1. Load Balancer Types

Hardware Load Balancers:

    F5 BIG-IP, Citrix ADC

    High performance, expensive

Software Load Balancers:

    NGINX, HAProxy, Envoy

    More flexible, cost-effective

Cloud Load Balancers:

    AWS ALB/NLB, GCP Load Balancer, Azure Load Balancer

    Managed service, auto-scaling

2. Load Balancing Algorithms
yaml

Round Robin:
  - Description: Rotates requests evenly
  - Use case: Equal capacity servers

Weighted Round Robin:
  - Description: Assigns weights based on capacity
  - Use case: Heterogeneous servers

Least Connections:
  - Description: Sends to server with fewest active connections
  - Use case: Long-lived connections

IP Hash:
  - Description: Sticky sessions based on client IP
  - Use case: Session persistence needed

Least Response Time:
  - Description: Chooses fastest responding server
  - Use case: Performance optimization

Detailed Design
1. Network Layer (Layer 4) Load Balancer

Components:
text

┌─────────────────────────────────────────────┐
│              L4 Load Balancer               │
├─────────────────────────────────────────────┤
│ - TCP/UDP load balancing                    │
│ - Network address translation (NAT)         │
│ - Port forwarding                           │
│ - Health checks (TCP connectivity)          │
└─────────────────────────────────────────────┘

Data Flow:

    Client connects to LB VIP (Virtual IP)

    LB performs NAT and forwards to backend

    Backend responds through LB

    LB translates address back to client

2. Application Layer (Layer 7) Load Balancer

Components:
text

┌─────────────────────────────────────────────┐
│              L7 Load Balancer               │
├─────────────────────────────────────────────┤
│ - HTTP/HTTPS load balancing                 │
│ - SSL termination                           │
│ - Content-based routing                     │
│ - Header-based routing                      │
│ - Path-based routing                        │
│ - Advanced health checks                    │
└─────────────────────────────────────────────┘

Routing Examples:
nginx

# Path-based routing
location /api/ {
    proxy_pass http://api_servers;
}

location /static/ {
    proxy_pass http://static_servers;
}

location / {
    proxy_pass http://web_servers;
}

System Components
1. Health Checking System
python

class HealthChecker:
    def check_servers(self, servers):
        for server in servers:
            health = self.perform_health_check(server)
            if health == "healthy":
                self.add_to_pool(server)
            else:
                self.remove_from_pool(server)
    
    def perform_health_check(self, server):
        # TCP check
        # HTTP check (200 status)
        # Custom endpoint check
        # Metrics-based check (CPU, memory)
        pass

2. Service Discovery
yaml

Service Registry:
  - etcd, Consul, Zookeeper
  - Automatic registration/deregistration
  - Health status tracking

Dynamic Configuration:
  - Add/remove servers without downtime
  - Update routing rules dynamically

3. Session Persistence

Methods:

    Source IP affinity: Same client IP → same server

    Cookie-based: Insert LB cookie with server info

    SSL session ID: Use SSL session for stickiness

4. SSL Termination
text

Client ──HTTPS──▶ LB ──HTTP──▶ Backend
         (SSL)          (Plain)

Benefits:

    Reduced CPU load on backend servers

    Centralized certificate management

    Better security monitoring

High Availability Design
Active-Active Setup
text

┌─────────────────┐    ┌─────────────────┐
│   Load Balancer │━━━━━│   Load Balancer │
│     (Active)    │    │     (Active)    │
└─────────────────┘    └─────────────────┘
         ┃                       ┃
         ┃                       ┃
┌────────┻───────────────────────┻────────┐
│             Backend Servers             │
└─────────────────────────────────────────┘

Active-Passive with Failover
text

┌─────────────────┐    ┌─────────────────┐
│   Load Balancer │━━━━━│   Load Balancer │
│     (Active)    │    │    (Standby)    │
└─────────────────┘    └─────────────────┘

Configuration Management
NGINX Example Configuration
nginx

upstream backend_servers {
    least_conn;
    server 10.0.1.10:80 weight=3;
    server 10.0.1.11:80 weight=2;
    server 10.0.1.12:80 weight=1;
    
    # Health checks
    check interval=3000 rise=2 fall=3 timeout=1000;
}

server {
    listen 80;
    
    location / {
        proxy_pass http://backend_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # Session persistence
        proxy_cookie_path / "/; sticky";
    }
    
    # Health check endpoint
    location /health {
        check_status;
        access_log off;
    }
}

Monitoring and Metrics
Key Metrics to Monitor
yaml

Performance Metrics:
  - Requests per second
  - Response time percentiles
  - Error rates (4xx, 5xx)
  - Throughput (MB/s)

System Metrics:
  - CPU and memory usage
  - Network I/O
  - Active connections
  - Connection rate

Business Metrics:
  - Availability percentage
  - Latency by endpoint
  - Cache hit ratios

Auto-scaling Integration
python

class AutoScaler:
    def scale_based_on_metrics(self):
        metrics = self.get_load_metrics()
        
        if metrics.cpu_usage > 80:
            self.add_servers(2)
        elif metrics.cpu_usage < 30:
            self.remove_servers(1)
        
        if metrics.request_rate > self.threshold:
            self.scale_out()

Security Considerations
1. DDoS Protection

    Rate limiting at LB level

    IP whitelisting/blacklisting

    Geo-blocking capabilities

2. Web Application Firewall (WAF)

    SQL injection prevention

    XSS protection

    Bot detection

3. TLS/SSL Security

    Perfect forward secrecy

    TLS version enforcement

    Certificate rotation

Traffic Management Features
1. Canary Deployments
yaml

Routing Rules:
  - 95% traffic → v1.0 servers
  - 5% traffic → v1.1 servers (canary)
  
Conditions:
  - Header-based routing (x-canary: true)
  - Percentage-based split
  - User-based segmentation

2. Circuit Breaker Pattern
python

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        
    def should_route_to_server(self, server):
        if server.failures >= self.failure_threshold:
            return False
        return True

Implementation Considerations
1. Choice Points

    L4 vs L7: Based on needed features

    Hardware vs Software: Based on scale and budget

    Cloud vs On-prem: Based on infrastructure

2. Performance Optimization

    Connection pooling

    Caching static content

    HTTP/2 support

    Compression

3. Disaster Recovery

    Multi-region deployment

    DNS failover strategies

    Backup configuration management
